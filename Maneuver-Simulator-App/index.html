<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maneuver</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts for digital-style typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <style>
        
        /* Apply the custom font and base styling */
        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: #000000;
        }
        /* Define custom colors for easier use in JS and to avoid purging */
        :root {
            --radar-green: #00FF00;
            --radar-white: #FFFFFF;
            --radar-faint-green: rgba(0, 255, 0, 0.5);
            --radar-faint-white: rgba(255, 255, 255, 0.5);
        }
        /* Ensure the canvas is responsive and has a cursor pointer for interaction */
        canvas {
            display: block;
            cursor: pointer;
        }
        /* Helper class for green text color */
        .text-radar-green {
            color: var(--radar-green);
        }
        /* Ensure the main content area fills the viewport height */
        .main-content {
             height: 100vh;
        }
        
        /* Button Styling */
        .control-btn {
            background-color: black;
            border-radius: 0.5rem;
            border-width: 1.5px;
            transition: all 0.2s ease-in-out;
            width: 100%; /* Make buttons fill the container */
            text-align: center;
            /* Added for better vertical alignment of text/icons */
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .control-btn.unselected {
            color: var(--radar-faint-green);
            border-color: var(--radar-faint-green);
        }
        .control-btn.selected {
            color: var(--radar-green);
            border-color: var(--radar-green);
        }
        .wind-value   { font-size: 150%; }  /* 1.5 × current size */
        .wind-label   { font-size: inherit; }/* unchanged */
    </style>
</head>
<body class="bg-black text-white overflow-hidden">

<div id="mobile-blocker"
     style="
        /* overlay covers the whole viewport */
        position:fixed; inset:0;
        background:#000; color:#0f0;
        z-index:9999;

        /* center the message block */
        display:flex; align-items:center; justify-content:center;

        /* text styling */
        font-family:'Share Tech Mono',monospace;
        font-size:clamp(1rem,4vw,1.95rem);
        line-height:1.4; text-align:center;
        padding:2rem;

        /* hidden by default – JS toggles to 'flex' */
        display:none;
     ">
  Maneuver is currently not compatible with cell-phone browsers. <br> <br>
  Please open this page on a laptop, desktop, or tablet. <br> <br>
  Questions? >> AheadFlank.ai@gmail.com
</div>

	<!-- Terms of Service Modal -->
<div id="tos-modal"
     style="
        position:fixed; inset:0;
        background:rgba(0,0,0,0.95); color:#0f0;
        z-index:9998;
        display:none; flex-direction:column;
        align-items:center; justify-content:flex-start;
        overflow-y:auto; padding:1rem;
        font-family:'Share Tech Mono',monospace;
     ">
  <pre id="tos-content" style="white-space:pre-wrap; max-width:60ch;">
User Agreement

Maneuver — Comprehensive User Agreement & Terms of Service

Effective Date: June 25, 2025

PLEASE READ THIS AGREEMENT CAREFULLY. By downloading, installing, accessing, or using the "Maneuver" application, including any associated software, website, or service (collectively, the “Services”), you agree to be bound by this User Agreement and Terms of Service (the “Agreement”).

This Agreement is a legally binding contract between you ("User," "you") and SpecK Innovations LLC ("we," "us," "our"). If you do not agree to all terms and conditions, do not access or use the Services.

1. CRITICAL SAFETY WARNING: FOR SIMULATION & EDUCATIONAL USE ONLY

You expressly acknowledge, understand, and agree that the Maneuver application is NOT a certified navigational instrument. It is designed and intended for educational, entertainment, and simulation purposes ONLY.

- DO NOT USE FOR REAL-WORLD NAVIGATION: You shall not, under any circumstances, use the App for actual navigation, collision avoidance, vessel operation, or any purpose where its failure, inaccuracy, or malfunction could lead to death, personal injury, or severe physical, environmental, or property damage.
- NO RELIANCE ON SIMULATED DATA: All data displayed within the App, including but not limited to radar plots, vessel positions, courses, speeds, and Closest Point of Approach (CPA) calculations, is simulated. It does not reflect real-world conditions and must not be relied upon for making navigational decisions.
- ALWAYS USE OFFICIAL EQUIPMENT: Safe marine navigation requires the use of approved, properly functioning, and certified navigational equipment (e.g., SOLAS-compliant RADAR, AIS, GPS, official electronic or paper charts). The App is not a substitute for such equipment or for prudent seamanship.

2. License Grant & Restrictions

- License: Subject to your full compliance with this Agreement, we grant you a limited, revocable, non-exclusive, non-transferable license to access and use the Services solely for your personal, non-commercial, and educational purposes.
- Restrictions: You may not:
    - Reverse-engineer, decompile, or otherwise attempt to discover the source code of the Services.
    - Copy, modify, or create derivative works based on the Services.
    - Resell, sublicense, lease, or otherwise distribute the Services.
    - Use the Services for any high-risk, life-critical, or commercial activity.

3. User Accounts & Security

- Accurate Information: If account registration is required, you agree to provide complete and accurate information and to keep it updated.
- Credentials: You are solely responsible for maintaining the confidentiality of your account credentials and for all activities that occur under your account. You must notify us immediately of any unauthorized use.

4. Intellectual Property

All software, documentation, trademarks, logos, and other materials provided as part of the Services are and remain the exclusive property of SpecK Innovations LLC and its licensors. No rights are granted except for the limited license expressly set forth herein.

5. Disclaimer of All Warranties

THE SERVICES ARE PROVIDED ON AN "AS IS" AND "AS AVAILABLE" BASIS, WITHOUT ANY WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED. TO THE FULLEST EXTENT PERMISSIBLE UNDER APPLICABLE LAW, WE DISCLAIM ALL WARRANTIES, INCLUDING BUT NOT LIMITED TO:

- WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
- WARRANTIES THAT THE SERVICES WILL BE UNINTERRUPTED, ERROR-FREE, SECURE, OR FREE FROM VIRUSES OR OTHER HARMFUL COMPONENTS.
- WARRANTIES REGARDING THE ACCURACY, RELIABILITY, COMPLETENESS, OR TIMELINESS OF THE SIMULATED DATA OR CALCULATIONS WITHIN THE SERVICES.

6. Limitation of Liability & Waiver of Claims

IN CONSIDERATION FOR BEING PERMITTED TO USE THE SERVICES, YOU HEREBY AGREE TO THE FOLLOWING:

TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT WILL SPECK INNOVATIONS LLC, ITS AFFILIATES, EMPLOYEES, AGENTS, OR SUCCESSORS BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR PUNITIVE DAMAGES, OR FOR ANY LOSS OF LIFE, PERSONAL INJURY, PROPERTY DAMAGE, LOSS OF PROFITS, REVENUES, DATA, OR GOODWILL, ARISING OUT OF OR IN CONNECTION WITH THE SERVICES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

OUR AGGREGATE LIABILITY SHALL NOT EXCEED THE GREATER OF (A) AMOUNTS PAID BY YOU TO US IN THE 12 MONTHS PRECEDING THE CLAIM OR (B) ONE HUNDRED U.S. DOLLARS (USD $100).

YOU HEREBY KNOWINGLY AND VOLUNTARILY WAIVE, RELEASE, AND DISCHARGE SPECK INNOVATIONS LLC FROM ANY AND ALL CLAIMS, DEMANDS, OR CAUSES OF ACTION THAT YOU MAY NOW HAVE OR HEREAFTER HAVE, KNOWN OR UNKNOWN, ARISING OUT OF OR IN ANY WAY CONNECTED WITH YOUR USE OF THE SERVICES.

7. Assumption of Risk & Indemnification

- Assumption of Risk: You voluntarily assume all risks, known and unknown, associated with using the Services, including the risk of relying on simulated data for real-world decisions.
- Indemnification: You agree to indemnify, defend, and hold harmless SpecK Innovations LLC from any claims, damages, liabilities, and expenses (including reasonable attorneys’ fees) arising from your use of the Services or your breach of this Agreement.

8. Termination

We may suspend or terminate your access to the Services immediately and without notice for any material breach of this Agreement, for any legal requirement, or to mitigate a security risk. Upon termination, your license to use the Services ceases immediately.

9. Governing Law & Dispute Resolution

- Governing Law: This Agreement shall be governed by and construed in accordance with the laws of the State of California, USA, without regard to its conflict of law principles.
- Arbitration: Any dispute, claim, or controversy arising from or relating to this Agreement shall be finally settled by binding arbitration administered by the American Arbitration Association under its Commercial Arbitration Rules.
- Class Action Waiver: To the fullest extent permitted by law, you and SpecK Innovations LLC agree that any dispute resolution proceedings will be conducted only on an individual basis and not in a class, consolidated, or representative action.

10. General Provisions

- Entire Agreement: This Agreement constitutes the entire agreement between you and SpecK Innovations LLC regarding the Services.
- Modifications: We reserve the right to modify this Agreement at any time. Your continued use of the App after any such change constitutes your acceptance of the new Agreement.
- Severability & Waiver: If any provision is held invalid, remaining provisions remain in full force. Failure to enforce any right is not a waiver of future enforcement.
- Assignment: You may not assign this Agreement without our prior written consent. We may assign it freely.
- Contact Information: Legal notices must be sent to: SpecK Innovations LLC, Email: aheadflank.ai@gmail.com
  </pre>
  <button id="tos-accept-btn" class="control-btn selected" style="margin-top:1rem;">ACCEPT</button>
</div>

<script>
	/* ✧✧✧ 2️⃣  DEVICE-GUARD SCRIPT ✧✧✧ */
	(function () {
	  const PHONE_MAX_WIDTH = 768;        // px – treat ≤ 768 px CSS width as “phone”
	  const blocker    = document.getElementById('mobile-blocker');
	  const root       = document.documentElement;   // <html> – your whole app
	
	  function isPhoneSized () {
	    return window.innerWidth <= PHONE_MAX_WIDTH;
	  }
	
	  function isPhoneUserAgent () {
	    return /Android|iPhone|iPod|Mobile|IEMobile|BlackBerry/i.test(navigator.userAgent);
	  }
	
	  function updateBlocker () {
	    const phone = isPhoneSized() || isPhoneUserAgent();
	    blocker.style.display = phone ? 'flex' : 'none';
	    root.style.overflow   = phone ? 'hidden' : '';   // stop scroll underneath
	  }
	
	  updateBlocker();                // on first load  window.addEventListener('resize', updateBlocker);
        })();
</script>

<script>
  // Terms of Service modal logic
  (function () {
    const modal = document.getElementById('tos-modal');
    const acceptBtn = document.getElementById('tos-accept-btn');
    const root = document.documentElement;
    const accepted = localStorage.getItem('userAgreementAccepted');
    if (!accepted) {
      modal.style.display = 'flex';
      root.style.overflow = 'hidden';
    }
    acceptBtn.addEventListener('click', () => {
      modal.style.display = 'none';
      root.style.overflow = '';
      const time = new Date().toISOString();
      localStorage.setItem('userAgreementAccepted', 'true');
      localStorage.setItem('userAgreementAcceptedTime', time);
      console.log('User agreement accepted at', time);
    });
  })();
</script>
	
    <main class="flex flex-row main-content relative">
        <!-- Maneuver Title in the upper left corner -->
        <div id="maneuver-title" class="absolute top-4 text-radar-green font-bold tracking-wide" style="font-size: 2.25rem; left: 10px;">
            Maneuver
        </div>

        <!-- Left Pane: Vertical Button Bar -->
        <div id="button-bar" class="p-2 flex flex-col items-center gap-2 justify-end flex-shrink-0">
            <!-- Simulation Controls -->
            <button id="btn-play-pause" class="control-btn selected p-2" title="Play/Pause Simulation">
                <svg id="icon-play" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mx-auto hidden" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                <svg id="icon-pause" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mx-auto" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
            </button>
            <button id="btn-ff" class="control-btn unselected p-2" title="Fast Forward">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mx-auto" fill="currentColor" viewBox="0 0 24 24"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg>
                <span id="ff-speed-indicator" class="absolute bottom-0 right-1 text-xs font-bold hidden"></span>
            </button>
            <button id="btn-rev" class="control-btn unselected p-2" title="Rewind">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mx-auto" fill="currentColor" viewBox="0 0 24 24"><path d="M11 18V6l-8.5 6 8.5 6zm-2-6l6.5 6V6l-6.5 6z"/></svg>
                <span id="rev-speed-indicator" class="absolute bottom-0 right-1 text-xs font-bold hidden"></span>
            </button>

            <span class="w-full border-t border-gray-600"></span>

            <!-- New Scenario Button -->
            <button id="btn-scen" class="control-btn selected p-2" title="Generate New Scenario">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mx-auto" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                </svg>
            </button>

            <span class="w-full border-t border-gray-600"></span>
            
            <!-- Add/Drop Track and Scenario Buttons -->
            <button id="btn-add-track" class="control-btn selected" title="Add New Track">+</button>
            <button id="btn-drop-track" class="control-btn selected" title="Drop Selected Track">-</button>
            
            <span class="w-full border-t border-gray-600"></span>

             <!-- Button Group 1 -->
            <button id="btn-wind" class="control-btn" title="Toggle Wind Display">WIND</button>
            <button id="btn-rmv" class="control-btn" title="Toggle Relative Motion Vectors">RM V</button>
            <button id="btn-cpa" class="control-btn" title="Toggle CPA Information">CPA</button>
            
            <span class="w-full border-t border-gray-600"></span>
            
            <!-- Button Group 2 -->
            <button id="btn-vector-time" class="control-btn selected" title="Toggle Vector Time (5, 15, 30 min)">15</button>

            <span class="w-full border-t border-gray-600"></span>

            <!-- Button Group 3 -->
            <button id="btn-range" class="control-btn selected" title="Toggle Radar Range">9.0</button>
        </div>

        <!-- Center Pane: Radar Display -->
	<div id="radar-container" class="flex-grow p-4 flex items-center justify-center relative" style="margin-left: 25px;">
            <div id="wind-data-display" class="absolute top-0 left-1/2 -translate-x-1/2 text-center text-radar-green z-10"></div>
            <div id="wind-data-display" class="absolute top-0 left-1/2 -translate-x-1/2 text-center text-radar-green z-10"></div>
            <canvas id="radarCanvas"></canvas>
        </div>

        <!-- Right Pane: Data Panels -->
        <div id="data-pane" class="flex-shrink-0 p-4 flex flex-col justify-start gap-8 overflow-y-auto text-radar-green">
            <!-- OwnShip Data -->
            <div>
                <p class="font-bold tracking-wide data-title">OwnShip</p>
                <div class="mt-2 pl-2 flex flex-col gap-1">
                    <div class="flex justify-between items-baseline"><span class="data-label">Crs</span><span id="ownship-crs" class="data-value"></span></div>
                    <div class="flex justify-between items-baseline"><span class="data-label">Spd</span><span id="ownship-spd" class="data-value"></span></div>
                </div>
            </div>
            <!-- Data Panels for selected track will be dynamically inserted here -->
            <div id="track-data-container"></div>
            <div id="rm-data-container"></div>
            <div id="cpa-data-container"></div>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('radarCanvas');
            const ctx = canvas.getContext('2d');
            const btnVectorTime = document.getElementById('btn-vector-time');
            const btnRmv = document.getElementById('btn-rmv');
            const btnCpa = document.getElementById('btn-cpa');
            const btnPlayPause = document.getElementById('btn-play-pause');
            const iconPlay = document.getElementById('icon-play');
            const iconPause = document.getElementById('icon-pause');
            const btnRange = document.getElementById('btn-range');
            const btnAddTrack = document.getElementById('btn-add-track');
            const btnDropTrack = document.getElementById('btn-drop-track');
            const btnWind = document.getElementById('btn-wind');
            const btnScen = document.getElementById('btn-scen');
            const btnFf = document.getElementById('btn-ff');
            const btnRev = document.getElementById('btn-rev');
            const ffSpeedIndicator = document.getElementById('ff-speed-indicator');
            const revSpeedIndicator = document.getElementById('rev-speed-indicator');

            // --- UI Elements for Scaling ---
            const buttonBar = document.getElementById('button-bar');
            const radarContainer = document.getElementById('radar-container');
            const dataPane = document.getElementById('data-pane');
            const trackDataContainer = document.getElementById('track-data-container');
            const rmDataContainer = document.getElementById('rm-data-container');
            const cpaDataContainer = document.getElementById('cpa-data-container');
            const windDataDisplay = document.getElementById('wind-data-display');
            const maneuverTitle = document.getElementById('maneuver-title'); // Get the new title element

            // --- Configuration ---
            const radarGreen = getComputedStyle(document.documentElement).getPropertyValue('--radar-green').trim();
            const radarWhite = getComputedStyle(document.documentElement).getPropertyValue('--radar-white').trim();
            const radarFaintGreen = getComputedStyle(document.documentElement).getPropertyValue('--radar-faint-green').trim();
            const radarFaintWhite = getComputedStyle(document.documentElement).getPropertyValue('--radar-faint-white').trim();
            
            // --- State Data ---
            let ownShip = { course: 91, speed: 12.7, id: 'ownShip', x: 0, y: 0 };
            let tracks = [
                { id: 1, initialBearing: 327, initialRange: 7.9, course: 255, speed: 6.1 },
                { id: 2, initialBearing: 345, initialRange: 6.5, course: 250, speed: 7.2 },
                { id: 3, initialBearing: 190, initialRange: 8.2, course: 75,  speed: 8.0 },
                { id: 4, initialBearing: 205, initialRange: 5.5, course: 70,  speed: 7.5 },
                { id: 5, initialBearing: 180, initialRange: 3.1, course: 72,  speed: 8.2 },
            ];
            
            let selectedTrackId = 1;
            let hoveredTrackId = null;
            let draggedItemId = null;
            let dragType = null;
            let lastMousePos = { x: 0, y: 0 };
            let lastTimestamp = 0;
	    let lastDomUpdate  = 0;
	    const DOM_UPDATE_INTERVAL = 200;    // ms (~5 FPS for panels)
	    let sceneDirty = true;              // mark when something really changed
            
            // --- Weather Data ---
            let trueWind = { 
                direction: 070, // Wind FROM 070 (North East)
                speed: 15,      // at 15 kts
                wPos: {x: 0, y: 0}, // Position of 'W' symbol for dragging direction
                arrowEndpoint: {x: 0, y: 0} // End of arrow for dragging speed
            };
            let relativeWind = {};

            // --- Feature Toggle States ---
            let maxRange = 9.0;
            const rangeScales = [1.0, 3.0, 6.0, 9.0];
            let vectorTimeInMinutes = 15;
            const vectorTimes = [5, 15, 30];
            let simulationSpeed = 1;
            const ffSpeeds = [10, 20, 30, 1];
            const revSpeeds = [-10, -20, -30, 1];
            let showRelativeMotion = false;
            let showCPAInfo = false;
            let isSimulationRunning = true;
            let showWeather = false; 


	/* ------------------------------------------------------------------ */
	/* OPTIMISATIONS (add after global consts)                           */
	/* ------------------------------------------------------------------ */

	/** Debounce function for expensive callbacks (e.g. window.resize) */
	
	function debounce(fn, delay = 150) {
	    let t;
	    return (...args) => {
	        clearTimeout(t);
	        t = setTimeout(() => fn.apply(this, args), delay);
	    };
	}

	/** Cache values so we only touch the DOM when something changed.   */
	
	function setText(id, value) {
	    const el = document.getElementById(id);
	    if (el._prev !== value) {     // simple diff
	        el.textContent = value;
	        el._prev = value;
	    }
	}

	/** mark the canvas dirty when interactive state changes */
	function markSceneDirty() { sceneDirty = true; }

	/* Hook the diff helper wherever you formerly used textContent ------ */
	function updateOwnShipPanel() {
	    setText('ownship-crs', `${formatBearing(ownShip.course)} T`);
	    setText('ownship-spd', `${ownShip.speed.toFixed(1)} KTS`);
	}

	/* …same pattern for other setText calls inside updateDataPanels() */
	
	/* Use debounced resize instead of raw listener --------------------- */
	window.addEventListener('resize', debounce(() => {
	    scaleUI();
	    markSceneDirty();
	}, 100));

	    function prepareStaticStyles() {
	       ctx.strokeStyle = radarFaintGreen;
	       ctx.fillStyle   = radarFaintGreen;
	       ctx.font        = `${Math.max(12, canvas.width * 0.04)}px 'Share Tech Mono', monospace`;
	    }

            // --- ANGLE CONVERSION HELPERS ---
            // Standardizes all angle math to prevent recurring bugs.
            // Navigational Bearing: 0 is North, clockwise.
            // Canvas Angle: 0 is East (right), counter-clockwise.
            const toRadians = (degrees) => degrees * Math.PI / 180;
            const toDegrees = (radians) => (radians * 180 / Math.PI + 360) % 360;
            const bearingToCanvasAngle = (bearing) => (450 - bearing) % 360;
            const canvasAngleToBearing = (angle) => (450 - angle) % 360;


            function updatePanelsAndRedraw() {
                updateOwnShipPanel();
                updateDataPanels();
                drawRadar();
            }

            // --- Formatting & Calculation Helpers ---
            function formatBearing(num) { return Math.round(num).toString().padStart(3, '0'); }
            function formatTime(hours) {
                if (hours < 0 || !isFinite(hours)) return '--:--:--';
                const totalSeconds = hours * 3600;
                const h = Math.floor(totalSeconds / 3600);
                const m = Math.floor((totalSeconds % 3600) / 60);
                const s = Math.floor(totalSeconds % 60);
                return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }
            function getRelativeQuarter(cpaBearing, ownShipCourse){
                const relativeBearing = (cpaBearing - ownShipCourse + 360) % 360;
                if(relativeBearing >= 0 && relativeBearing < 90) return 'STBD BOW';
                if(relativeBearing >= 90 && relativeBearing < 180) return 'STBD QTR';
                if(relativeBearing >= 180 && relativeBearing < 270) return 'PORT QTR';
                return 'PORT BOW';
            }
            function getAspect(targetAngle){
                if(targetAngle >= 337.5 || targetAngle < 22.5) return 'BOW';
                if(targetAngle >= 22.5 && targetAngle < 67.5) return 'STBD BOW';
                if(targetAngle >= 67.5 && targetAngle < 112.5) return 'STBD BM';
                if(targetAngle >= 112.5 && targetAngle < 157.5) return 'STBD QTR';
                if(targetAngle >= 157.5 && targetAngle < 202.5) return 'STERN';
                if(targetAngle >= 202.5 && targetAngle < 247.5) return 'PORT QTR';
                if(targetAngle >= 247.5 && targetAngle < 292.5) return 'PORT BM';
                if(targetAngle >= 292.5 && targetAngle < 337.5) return 'PORT BOW';
                return 'N/A';
            }
            function getBearingRate(relativeVelocity, targetPosition, range){
                const crossProduct = targetPosition.x * relativeVelocity.y - targetPosition.y * relativeVelocity.x;
                if(range < 0.01) return '0.00 STEADY';
                const bearingRateRadPerHour = crossProduct / (range * range);
                const bearingRateDpm = (bearingRateRadPerHour * 180 / Math.PI) / 60;
                let direction;
                if(Math.abs(bearingRateDpm) < 0.01) {
                    direction = 'STEADY';
                } else if (bearingRateDpm > 0) {
                    direction = 'LEFT';
                } else {
                    direction = 'RIGHT';
                }
                return `${Math.abs(bearingRateDpm).toFixed(2)} ${direction}`;
            }
            
            function calculateWindData() {
                // Convert wind "from" bearing to a "to" vector angle
                const trueWindVectorAngle = (trueWind.direction + 180) % 360;
                const trueWindRad = toRadians(bearingToCanvasAngle(trueWindVectorAngle));
                const trueWindVelX = trueWind.speed * Math.cos(trueWindRad);
                const trueWindVelY = trueWind.speed * Math.sin(trueWindRad);

                const ownShipRad = toRadians(bearingToCanvasAngle(ownShip.course));
                const ownShipVelX = ownShip.speed * Math.cos(ownShipRad);
                const ownShipVelY = ownShip.speed * Math.sin(ownShipRad);

                const relWindVelX = trueWindVelX - ownShipVelX;
                const relWindVelY = trueWindVelY - ownShipVelY;

                relativeWind.speed = Math.sqrt(relWindVelX**2 + relWindVelY**2);
                const relWindVectorCanvasAngle = toDegrees(Math.atan2(relWindVelY, relWindVelX));
                
                relativeWind.vectorDirection = canvasAngleToBearing(relWindVectorCanvasAngle);
            }


             function calculateAllData(track) {
                // Calculate position relative to own ship
                // Note: Simulation uses X for Easting, Y for Northing.
                const dx = track.x - ownShip.x;
                const dy = track.y - ownShip.y;
                track.range = Math.sqrt(dx**2 + dy**2);
                
                // Get bearing from ownship to track. atan2(x, y) for bearing from North.
                track.bearing = (toDegrees(Math.atan2(dx, dy)) + 360) % 360;
                
                // Ownship vector
                const ownShipCanvasAngle = toRadians(bearingToCanvasAngle(ownShip.course));
                const ownShipVelX = ownShip.speed * Math.cos(ownShipCanvasAngle);
                const ownShipVelY = ownShip.speed * Math.sin(ownShipCanvasAngle);
                
                // Target vector
                const targetCourseCanvasAngle = toRadians(bearingToCanvasAngle(track.course));
                const targetVelX = track.speed * Math.cos(targetCourseCanvasAngle);
                const targetVelY = track.speed * Math.sin(targetCourseCanvasAngle);
                
                // Relative vector
                const relVelX = targetVelX - ownShipVelX;
                const relVelY = targetVelY - ownShipVelY;
                const relSpeed = Math.sqrt(relVelX**2 + relVelY**2);
                const relVectorCanvasAngle = toDegrees(Math.atan2(relVelY, relVelX));
                
                track.rmVector = { x: relVelX, y: relVelY, speed: relSpeed, bearing: canvasAngleToBearing(relVectorCanvasAngle) };
                
                // CPA Calculation
                const targetPosCanvasAngle = toRadians(bearingToCanvasAngle(track.bearing));
                const targetPosX = track.range * Math.cos(targetPosCanvasAngle);
                const targetPosY = track.range * Math.sin(targetPosCanvasAngle);

                const dotProduct = (targetPosX * relVelX) + (targetPosY * relVelY);
                if (relSpeed < 0.001) {
                    track.cpa = { range: '--', time: '--:--:--', brg: '--' };
                    track.hasPassedCPA = true;
                } else {
                    const tcpa = -dotProduct / (relSpeed**2);
                    track.hasPassedCPA = tcpa < 0;
                    const cpaX = targetPosX + tcpa * relVelX;
                    const cpaY = targetPosY + tcpa * relVelY;
                    track.cpaPosition = { x: cpaX, y: cpaY };

                    if (track.hasPassedCPA) {
                        track.cpa = { range: '-- NM', time: '--:--:--', brg: '- -' };
                    } else {
                        const cpaRange = Math.sqrt(cpaX**2 + cpaY**2);
                        const cpaCanvasAngle = toDegrees(Math.atan2(cpaY, cpaX));
                        const cpaBearing = canvasAngleToBearing(cpaCanvasAngle);
                        const cpaQuarter = getRelativeQuarter(cpaBearing, ownShip.course);
                        track.cpa = {
                            range: `${cpaRange.toFixed(2)} NM`,
                            time: formatTime(tcpa),
                            brg: `${formatBearing(cpaBearing)} T / ${cpaQuarter}`
                        };
                    }
                }
                
                // Other data
                const ownshipBearingFromTarget = (track.bearing + 180) % 360;
                const targetAngle = (ownshipBearingFromTarget - track.course + 360) % 360;
                track.rm = {
                    dir: `${formatBearing(track.rmVector.bearing)} T`,
                    spd: `${relSpeed.toFixed(1)} KTS`,
                    rate: getBearingRate({x: relVelX, y: relVelY}, {x: targetPosX, y: targetPosY}, track.range),
                    angle: `${formatBearing(targetAngle)} DEG`,
                    aspect: getAspect(targetAngle)
                };
            }

            // --- UI Update Functions ---
            function updateOwnShipPanel() { 
                document.getElementById('ownship-crs').textContent = `${formatBearing(ownShip.course)} T`; 
                document.getElementById('ownship-spd').textContent = `${ownShip.speed.toFixed(1)} KTS`; 
            }
            
            function updateDataPanels() {
                const selectedTrack = tracks.find(t => t.id === selectedTrackId);

                // Always display track data, or placeholders if no track is selected
                trackDataContainer.innerHTML = `<p class="font-bold tracking-wide data-title">TRACK ${selectedTrack ? selectedTrack.id : '--'}</p>
                    <div class="mt-2 pl-2 flex flex-col gap-1">
                        <div class="flex justify-between items-baseline"><span class="data-label">Brg</span><span class="data-value text-right">${selectedTrack ? formatBearing(selectedTrack.bearing) + ' T' : '--'}</span></div>
                        <div class="flex justify-between items-baseline"><span class="data-label">Rng</span><span class="data-value text-right">${selectedTrack ? selectedTrack.range.toFixed(2) + ' NM' : '--'}</span></div>
                        <div class="flex justify-between items-baseline"><span class="data-label">Crs</span><span class="data-value text-right">${selectedTrack ? formatBearing(selectedTrack.course) + ' T' : '--'}</span></div>
                        <div class="flex justify-between items-baseline"><span class="data-label">Spd</span><span class="data-value text-right">${selectedTrack ? selectedTrack.speed.toFixed(1) + ' KTS' : '--'}</span></div>
                    </div>`;

                // Display relative motion data, or placeholders if toggled off or no track selected
                const showRM = selectedTrack && showRelativeMotion;
                rmDataContainer.innerHTML = `<p class="font-bold tracking-wide data-title">Relative Motion</p>
                    <div class="mt-2 pl-2 flex flex-col gap-1">
                        <div class="flex justify-between items-baseline"><span class="data-label">Direction RM</span><span class="data-value text-right">${showRM ? selectedTrack.rm.dir : '--'}</span></div>
                        <div class="flex justify-between items-baseline"><span class="data-label">Spd RM</span><span class="data-value text-right">${showRM ? selectedTrack.rm.spd : '--'}</span></div>
                        <div class="flex justify-between items-baseline"><span class="data-label">Brg Rate</span><span class="data-value text-right">${showRM ? selectedTrack.rm.rate : '--'}</span></div>
                        <div class="flex justify-between items-baseline"><span class="data-label">Tgt Angle</span><span class="data-value text-right">${showRM ? selectedTrack.rm.angle : '--'}</span></div>
                        <div class="flex justify-between items-baseline"><span class="data-label">Aspect</span><span class="data-value text-right">${showRM ? selectedTrack.rm.aspect : '--'}</span></div>
                    </div>`;
                
                // Display CPA data, or placeholders if toggled off, no track selected, or CPA has passed
                const showCPA = selectedTrack && showCPAInfo && !selectedTrack.hasPassedCPA;
                cpaDataContainer.innerHTML = `<p class="font-bold tracking-wide data-title">CPA</p>
                    <div class="mt-2 pl-2 flex flex-col gap-1">
                        <div class="flex justify-between items-baseline"><span class="data-label">Brg</span><span class="data-value text-right">${showCPA ? selectedTrack.cpa.brg : '--'}</span></div>
                        <div class="flex justify-between items-baseline"><span class="data-label">Rng</span><span class="data-value text-right">${showCPA ? selectedTrack.cpa.range : '--'}</span></div>
                        <div class="flex justify-between items-baseline"><span class="data-label">Time</span><span class="data-value text-right">${showCPA ? selectedTrack.cpa.time : '--'}</span></div>
                    </div>`;

                scaleUI();
            }
            
            function updateButtonStyles() { 
                btnWind.className = `control-btn ${showWeather ? 'selected' : 'unselected'}`;
                btnRmv.className = `control-btn ${showRelativeMotion ? 'selected' : 'unselected'}`;
                btnCpa.className = `control-btn ${showCPAInfo ? 'selected' : 'unselected'}`;
                                        
                btnPlayPause.className = `control-btn p-2 ${isSimulationRunning ? 'selected' : 'unselected'}`;
                iconPlay.classList.toggle('hidden', isSimulationRunning);
                iconPause.classList.toggle('hidden', !isSimulationRunning);

                btnFf.className = `control-btn p-2 ${simulationSpeed > 1 ? 'selected' : 'unselected'}`;
                btnRev.className = `control-btn p-2 ${simulationSpeed < 1 ? 'selected' : 'unselected'}`;
            }

            // --- Drawing Functions ---
function updateWindDataDisplay() {
    if (!showWeather) {
        windDataDisplay.innerHTML = '';
        return;
    }

    const trueDir = formatBearing(trueWind.direction);
    const trueSpd = trueWind.speed.toFixed(0);
    const trueHtml =
        `<span class="wind-label">True Wind&nbsp;&nbsp;</span>` +
        `<span class="wind-value">${trueDir}&nbsp;T&nbsp;&nbsp;${trueSpd}&nbsp;KTS</span>`;

    let relHtml = '';
    if (showRelativeMotion) {
        const relDir = formatBearing(relativeWind.vectorDirection);
        const relSpd = relativeWind.speed.toFixed(0);
        relHtml =
            `<span class="wind-label">&nbsp;&nbsp;Relative&nbsp;Wind:&nbsp;</span>` +
            `<span class="wind-value">${relDir}&nbsp;T&nbsp;&nbsp;${relSpd}&nbsp;KTS</span>`;
    }

    windDataDisplay.innerHTML = trueHtml + relHtml;
}


            function drawWeatherInfo(center, radius) {
                const windFromAngle = toRadians(bearingToCanvasAngle(trueWind.direction));
                const pixelsPerKnot = 4;
                const arrowLength = trueWind.speed * pixelsPerKnot;

                const wX = center + Math.cos(windFromAngle) * radius;
                const wY = center - Math.sin(windFromAngle) * radius; // Y-axis inverted
                trueWind.wPos = {x: wX, y: wY}; 

                const startX = wX;
                const startY = wY;
                const endX = startX - Math.cos(windFromAngle) * arrowLength;
                const endY = startY + Math.sin(windFromAngle) * arrowLength; // Y-axis inverted
                trueWind.arrowEndpoint = {x: endX, y: endY}; 
		    
	/* --------- draw “W” label and solid true‑wind arrow (restored code) --- */
	ctx.save();
	ctx.strokeStyle = radarFaintGreen;
	ctx.fillStyle   = radarFaintGreen;

	ctx.font        = `${Math.max(12, radius * 0.08)}px 'Share Tech Mono', monospace`;
	ctx.textAlign   = 'center';
	ctx.textBaseline = 'middle';
	ctx.fillText('W', wX, wY);

	ctx.lineWidth = 2;
	ctx.beginPath();
	ctx.moveTo(startX, startY);
	ctx.lineTo(endX, endY);
	ctx.stroke();

	const arrowAngle = Math.atan2(endY - startY, endX - startX);
	ctx.beginPath();
	ctx.moveTo(endX, endY);
	ctx.lineTo(endX - 15 * Math.cos(arrowAngle - Math.PI / 6),
                 endY - 15 * Math.sin(arrowAngle - Math.PI / 6));
	ctx.lineTo(endX - 15 * Math.cos(arrowAngle + Math.PI / 6),
                 endY - 15 * Math.sin(arrowAngle + Math.PI / 6));
	ctx.closePath();
	ctx.fill();
	ctx.restore();
	


                if (showRelativeMotion) {
                    const pixelsPerNm = radius / maxRange;
                    const timeInHours = vectorTimeInMinutes / 60;
                    const vectorDistPixels = relativeWind.speed * timeInHours * pixelsPerNm;
                    const relWindCanvasAngle = toRadians(bearingToCanvasAngle(relativeWind.vectorDirection));
                    
                    const vecEndX = center + vectorDistPixels * Math.cos(relWindCanvasAngle);
                    const vecEndY = center - vectorDistPixels * Math.sin(relWindCanvasAngle); // Y-axis inverted

                    ctx.save();
                    ctx.strokeStyle = radarFaintGreen;
                    ctx.lineWidth = 1.8;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(center, center);
                    ctx.lineTo(vecEndX, vecEndY);
                    ctx.stroke();
                    ctx.restore();
                }
            }
            
            function drawRadar() {
                const size = canvas.width;
                if (size === 0) return;
                const center = size / 2;
                const radius = size / 2 * 0.9;
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, size, size);
                drawRangeRings(center, radius);
                drawRangeLabels(center, radius);
                
                if (showWeather) {
                    drawWeatherInfo(center, radius);
                    updateWindDataDisplay();
                } else {
                    updateWindDataDisplay(); // Clear the display
                }
                drawOwnShipIcon(center, radius);
                tracks.forEach(track => {
                    drawTarget(center, radius, track);
                    if(showRelativeMotion) {
                        drawRelativeMotionVector(center, radius, track);
                    }
                });
                if(showCPAInfo && selectedTrackId !== null) {
                    drawCPAIndicator(center, radius);
                }
                if (selectedTrackId !== null) {
                    const track = tracks.find(t => t.id === selectedTrackId);
                    if (track) drawBearingLine(center, radius, track);
                    drawSelectionIndicator(center, radius, selectedTrackId, radarWhite, 1.5);
                }
                if (hoveredTrackId !== null && hoveredTrackId !== selectedTrackId) {
                    drawSelectionIndicator(center, radius, hoveredTrackId, radarFaintWhite, 1);
                }
            }
            
            function drawRangeRings(center, radius) { ctx.strokeStyle = radarFaintGreen; ctx.lineWidth = 0.9; ctx.beginPath(); ctx.arc(center, center, radius, 0, 2 * Math.PI); ctx.stroke(); for (let i = 1; i < 3; i++) { ctx.beginPath(); ctx.arc(center, center, radius * (i / 3), 0, 2 * Math.PI); ctx.stroke(); } }
            function drawRangeLabels(center, radius) { ctx.fillStyle = radarGreen; ctx.font = `${Math.max(11, radius * 0.038)}px 'Share Tech Mono',monospace`; ctx.textAlign = 'left'; ctx.textBaseline = 'middle'; for (let i = 1; i <= 3; i++) { const ringRadius = radius * (i / 3); const range = maxRange * (i / 3); ctx.fillText(range.toFixed(1), center + ringRadius + 5, center); } }
            function drawOwnShipIcon(center, radius) {
                ctx.strokeStyle = radarGreen;
                ctx.lineWidth = 1.4;
                const iconRadius = canvas.width * 0.014;
                ctx.beginPath();
                ctx.arc(center, center, iconRadius, 0, 2 * Math.PI);
                ctx.stroke();
                const timeInHours = vectorTimeInMinutes / 60;
                const pixelsPerNm = radius / maxRange;
                const vectorDistPixels = ownShip.speed * timeInHours * pixelsPerNm;
                const courseAngle = toRadians(bearingToCanvasAngle(ownShip.course));
                const endX = center + vectorDistPixels * Math.cos(courseAngle);
                const endY = center - vectorDistPixels * Math.sin(courseAngle); 
                ownShip.vectorEndpoint = { x: endX, y: endY };
                ctx.beginPath();
                ctx.moveTo(center, center);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
            
            function getTargetCoords(center, radius, track) { 
                const angleRad = toRadians(bearingToCanvasAngle(track.bearing)); 
                const distOnCanvas = (track.range / maxRange) * radius; 
                const x = center + distOnCanvas * Math.cos(angleRad); 
                const y = center - distOnCanvas * Math.sin(angleRad); // Invert Y-axis
                return { x, y }; 
            }

            function drawTarget(center, radius, track) {
                const { x, y } = getTargetCoords(center, radius, track);
                const targetSize = Math.max(11, radius * 0.038);
                ctx.strokeStyle = radarGreen;
                ctx.lineWidth = 1.8;
                ctx.strokeRect(x - targetSize / 2, y - targetSize / 2, targetSize, targetSize);
                const timeInHours = vectorTimeInMinutes / 60;
                const pixelsPerNm = radius / maxRange;
                const vectorDistPixels = track.speed * timeInHours * pixelsPerNm;
                const courseAngle = toRadians(bearingToCanvasAngle(track.course));
                const endX = x + vectorDistPixels * Math.cos(courseAngle);
                const endY = y - vectorDistPixels * Math.sin(courseAngle); 
                track.vectorEndpoint = { x: endX, y: endY };
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                ctx.fillStyle = radarGreen;
                ctx.font = `${Math.max(11, radius * 0.038)}px 'Share Tech Mono', monospace`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(track.id, x + targetSize / 2 + 3, y + targetSize / 2 + 3);
            }
            function drawRelativeMotionVector(center, radius, track) { 
                if (!track.rmVector) return; 
                const { x: startX, y: startY } = getTargetCoords(center, radius, track); 
                const timeInHours = vectorTimeInMinutes / 60; 
                const pixelsPerNm = radius / maxRange; 
                const vectorDistPixels = track.rmVector.speed * timeInHours * pixelsPerNm; 
                const vectorAngleRad = toRadians(bearingToCanvasAngle(track.rmVector.bearing)); 
                const endX = startX + vectorDistPixels * Math.cos(vectorAngleRad); 
                const endY = startY - vectorDistPixels * Math.sin(vectorAngleRad);
                ctx.save(); 
                ctx.strokeStyle = radarGreen; 
                ctx.lineWidth = 1.8; 
                ctx.setLineDash([5, 5]); 
                ctx.beginPath(); 
                ctx.moveTo(startX, startY); 
                ctx.lineTo(endX, endY); 
                ctx.stroke(); 
                ctx.restore(); 
            }
            function drawCPAIndicator(center, radius) {
                const track = tracks.find(t => t.id === selectedTrackId);
                if (!track || track.hasPassedCPA || !track.cpaPosition) return;
                const pixelsPerNm = radius / maxRange;
                
                const cpaBearing = (toDegrees(Math.atan2(track.cpaPosition.x, track.cpaPosition.y)) + 360) % 360;
                const cpaCanvasAngle = toRadians(bearingToCanvasAngle(cpaBearing));
                const cpaRange = Math.sqrt(track.cpaPosition.x**2 + track.cpaPosition.y**2);

                const cpaDistCanvas = cpaRange * pixelsPerNm;

                const cpaX = center + cpaDistCanvas * Math.cos(cpaCanvasAngle);
                const cpaY = center - cpaDistCanvas * Math.sin(cpaCanvasAngle); 
                
                ctx.beginPath();
                ctx.arc(cpaX, cpaY, 4, 0, 2 * Math.PI);
                ctx.fillStyle = radarGreen;
                ctx.fill();
                ctx.save();
                ctx.strokeStyle = radarFaintGreen;
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 3]);
                ctx.beginPath();
                ctx.moveTo(center, center);
                ctx.lineTo(cpaX, cpaY);
                ctx.stroke();
                ctx.restore();
            }

            function drawBearingLine(center, radius, track) {
                const { x, y } = getTargetCoords(center, radius, track);
                ctx.save();
                ctx.strokeStyle = radarWhite;
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 4]);
                ctx.beginPath();
                ctx.moveTo(center, center);
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.restore();
            }
            function drawSelectionIndicator(center, radius, trackId, color, lineWidth) { const track = tracks.find(t => t.id === trackId); if (!track) return; const { x, y } = getTargetCoords(center, radius, track); const targetSize = Math.max(11, radius * 0.038); const indicatorRadius = targetSize * 1.2; ctx.strokeStyle = color; ctx.lineWidth = lineWidth; ctx.beginPath(); ctx.arc(x, y, indicatorRadius, 0, 2 * Math.PI); ctx.stroke(); }
            function distToSegment(p, v, w) { const l2 = (v.x - w.x)**2 + (v.y - w.y)**2; if (l2 == 0) return Math.sqrt((p.x - v.x)**2 + (p.y - v.y)**2); let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2; t = Math.max(0, Math.min(1, t)); return Math.sqrt((p.x - (v.x + t * (w.x - v.x)))**2 + (p.y - (v.y + t * (w.y - v.y)))**2); }
            
            // --- Hit Detection & Interaction ---
            function getInteractiveItemAt(mouseX, mouseY) {
                const center = canvas.width / 2;
                const radius = center * 0.9;
                const hitTolerance = 15;
                const minVecPickDistance = 25;

                if (showWeather) {
                    const distToW = Math.sqrt((mouseX - trueWind.wPos.x)**2 + (mouseY - trueWind.wPos.y)**2);
                    if (distToW < hitTolerance) {
                        return { type: 'windDirection', id: 'trueWind' };
                    }
                    const distToArrowhead = Math.sqrt((mouseX - trueWind.arrowEndpoint.x)**2 + (mouseY - trueWind.arrowEndpoint.y)**2);
                    if (distToArrowhead < hitTolerance) {
                        return { type: 'windSpeed', id: 'trueWind' };
                    }
                }

                // --- Check for track icon hits first ---
                for (const track of tracks) {
                    const {x, y} = getTargetCoords(center, radius, track);
                    const size = Math.max(11, radius * 0.038) * 1.5;
                    if (mouseX > x - size/2 && mouseX < x + size/2 &&
                        mouseY > y - size/2 && mouseY < y + size/2) {
                        return {type: 'icon', id: track.id};
                    }
                }

                // --- Then check for vector hits, but only if far enough from the start point ---
                const allVessels = [ownShip, ...tracks];
                for (const vessel of allVessels) {
                    if (!vessel.vectorEndpoint) continue;

                    const startPt = (vessel.id === 'ownShip')
                        ? {x: center, y: center}
                        : getTargetCoords(center, radius, vessel);
                    
                    const distFromStart = Math.hypot(mouseX - startPt.x, mouseY - startPt.y);
                    if (distFromStart < minVecPickDistance) continue;

                    const endPt = vessel.vectorEndpoint;
                    const dist = distToSegment({x: mouseX, y: mouseY}, startPt, endPt);
                    if (dist < hitTolerance) {
                        return {type: 'vector', id: vessel.id};
                    }
                }
                return null;
            }
            
            function handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const center = canvas.width / 2;
                
                if (!draggedItemId) {
                    const item = getInteractiveItemAt(mouseX, mouseY);
                    const newHoverId = item ? item.id : null;
                    if (newHoverId !== hoveredTrackId) {
                        hoveredTrackId = newHoverId;
                    }
                    return;
                }

                // --- Dragging Wind ---
                if (draggedItemId === 'trueWind') {
                    const dx = mouseX - center;
                    const dy = -(mouseY - center);
                    const newCanvasAngleRad = Math.atan2(dy, dx);

                    if (dragType === 'windDirection') {
                        trueWind.direction = canvasAngleToBearing(toDegrees(newCanvasAngleRad));
			markSceneDirty();
                    } else if (dragType === 'windSpeed') {
                        const pixelsPerKnot = 4;
                        const windFromAngle = toRadians(bearingToCanvasAngle(trueWind.direction));
                        const radius = center * 0.9;
                        
                        const mouseVecX = mouseX - center;
                        const mouseVecY = -(mouseY - center);
                        const windVecX = Math.cos(windFromAngle);
                        const windVecY = Math.sin(windFromAngle);
                        
                        const projectedLength = mouseVecX * windVecX + mouseVecY * windVecY;
                        const arrowPixelLength = projectedLength - radius;
                        
                        trueWind.speed = Math.max(0, -arrowPixelLength / pixelsPerKnot);
			markSceneDirty();
                    }
                    return;
                }

                // --- Dragging Tracks or Vectors ---
                const pixelsPerNm = (center * 0.9) / maxRange;
                
                if (dragType === 'icon') {
                    const track = tracks.find(t => t.id === draggedItemId);
                    if (track) {
                        const deltaX_pixels = mouseX - lastMousePos.x;
                        const deltaY_pixels = mouseY - lastMousePos.y;

                        const deltaX_nm = deltaX_pixels / pixelsPerNm;
                        const deltaY_nm = deltaY_pixels / pixelsPerNm;
                        
                        track.x += deltaX_nm;
                        track.y -= deltaY_nm;
                    }
                } else if (dragType === 'vector') {
                    const timeInHours = vectorTimeInMinutes / 60;
                    const vessel = (draggedItemId === 'ownShip') ? ownShip : tracks.find(t => t.id === draggedItemId);
                    const startPoint = (vessel.id === 'ownShip') ? { x: center, y: center } : getTargetCoords(center, (center * 0.9), vessel);
                    
                    const dx = mouseX - startPoint.x;
                    const dy = -(mouseY - startPoint.y);
                    
                    const newCanvasAngleRad = Math.atan2(dy, dx);
                    let newCourse = canvasAngleToBearing(toDegrees(newCanvasAngleRad));
                    const distOnCanvas = Math.sqrt(dx * dx + dy * dy);
                    const newSpeed = distOnCanvas / pixelsPerNm / timeInHours;
                    
                    vessel.course = newCourse;
                    if (vessel.id !== 'ownShip') {
                        vessel.speed = Math.max(2, newSpeed);
                    } else {
                        vessel.speed = Math.max(0, newSpeed);
                    }
                }
                
                lastMousePos = { x: mouseX, y: mouseY };
            }
            
            function handleMouseDown(e) {
                if (e.button !== 0) return; 
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const item = getInteractiveItemAt(mouseX, mouseY);
                if (item) {
                    draggedItemId = item.id;
                    dragType = item.type;
                    lastMousePos = { x: mouseX, y: mouseY };
                    if (item.id !== 'ownShip' && item.id !== 'trueWind') {
                        selectedTrackId = item.id;
                    }
                    markSceneDirty();
                }
            }

            function handleMouseUp() { 
                draggedItemId = null; 
                dragType = null; 
            }
            
            // --- Animation Loop ---
            function updatePhysics(deltaTime) {
                if (!isSimulationRunning) return;

                const timeMultiplier = deltaTime / 3600 * simulationSpeed;
                const ownShipDist = ownShip.speed * timeMultiplier;
                ownShip.x += ownShipDist * Math.sin(toRadians(ownShip.course));
                ownShip.y += ownShipDist * Math.cos(toRadians(ownShip.course));
                
                tracks.forEach(track => {
                    if (draggedItemId === track.id) return;
                    
                    const dist = track.speed * timeMultiplier;
                    track.x += dist * Math.sin(toRadians(track.course));
                    track.y += dist * Math.cos(toRadians(track.course));
                });
            }


	    function gameLoop(timestamp) {
	        const deltaTime = (timestamp - lastTimestamp) || 0;
	        lastTimestamp = timestamp;
	
	        // --- simulation math --------------------------------------------------
	            if (isSimulationRunning) {
	            
                    updatePhysics(deltaTime / 1000);
	            sceneDirty = true;
		}
	
	      // --- draw canvas only when needed -------------------------------------
	          if (sceneDirty) {
		    
		    tracks.forEach(calculateAllData);
		    calculateWindData();
		    drawRadar();
		    sceneDirty = false; // Corrected typo from SceneDirty
		}
	
	       // --- update DOM at low frequency --------------------------------------
		 if (timestamp - lastDomUpdate >= DOM_UPDATE_INTERVAL) {
		
		 updateOwnShipPanel();
		 updateDataPanels();      // ← now *without* scaleUI inside
		 updateButtonStyles();
		 lastDomUpdate = timestamp;
		}
	
		requestAnimationFrame(gameLoop);
	}

            // --- UI Scaling Function ---
            function scaleUI() {
                const baseDim = 900;
                const viewportMin = Math.min(window.innerWidth, window.innerHeight);
                const scaleFactor = Math.max(0.7, Math.min(1.5, viewportMin / baseDim));

                const size = Math.min(radarContainer.clientWidth, radarContainer.clientHeight) * 0.9;
                canvas.width = size;
                canvas.height = size;

                buttonBar.style.width = `${60 * scaleFactor}px`;
                const buttons = document.querySelectorAll('.control-btn');
                buttons.forEach(btn => {
                    btn.style.fontSize = `${0.75 * scaleFactor}rem`;
                    btn.style.padding = `${0.5 * scaleFactor}rem ${0.25 * scaleFactor}rem`;
		
		prepareStaticStyles();
	        markSceneDirty();

                });

                const largeButtonFontSize = 2.25;
                btnAddTrack.style.fontSize = `${largeButtonFontSize * scaleFactor}rem`;
                btnAddTrack.style.lineHeight = '1';
                btnDropTrack.style.fontSize = `${largeButtonFontSize * scaleFactor}rem`;
                btnDropTrack.style.lineHeight = '1';

                const dataValueFontSize = 1.5;
                windDataDisplay.style.fontSize = `${(dataValueFontSize / 2) * scaleFactor}rem`;
                windDataDisplay.style.padding = `${10 * scaleFactor}px`;

                const dividers = document.querySelectorAll('#button-bar > .border-t');
                dividers.forEach(div => {
                    div.style.margin = `${10 * scaleFactor}px 0`;
                });

                dataPane.style.width = `${320 * scaleFactor}px`;
                dataPane.style.padding = `${16 * scaleFactor}px`;
                dataPane.style.gap = `${32 * scaleFactor}px`;

                // Scale the Maneuver title and other data titles
                const titleFontSize = 1.25 * scaleFactor;
                // The maneuver title size is now set directly in its style and will not scale.
                // If scaling is desired for the larger title, it should be done here.
                // For now, respecting the user's hardcoded "double size" instruction.
                document.querySelectorAll('.data-title').forEach(el => el.style.fontSize = `${titleFontSize}rem`);

                document.querySelectorAll('.data-label').forEach(el => el.style.fontSize = `${1 * scaleFactor}rem`);
                document.querySelectorAll('.data-value').forEach(el => el.style.fontSize = `${dataValueFontSize * scaleFactor}rem`);

                
            }

            // --- Track Management Functions ---
            function addTrack() {
                const existingIds = tracks.map(t => t.id).sort((a,b) => a - b);
                let newId = 1;
                while (existingIds.includes(newId)) {
                    newId++;
                }

                const newTrack = {
                    id: newId,
                    initialBearing: Math.random() * 360,
                    initialRange: maxRange * (0.1 + Math.random() * 0.8),
                    course: Math.random() * 360,
                    speed: 2 + Math.random() * 13
                };

                newTrack.x = ownShip.x + newTrack.initialRange * Math.sin(toRadians(newTrack.initialBearing));
                newTrack.y = ownShip.y + newTrack.initialRange * Math.cos(toRadians(newTrack.initialBearing));
                
                tracks.push(newTrack);
                selectedTrackId = newId;
            }

            function dropTrack() {
                if (selectedTrackId === null) return;

                const trackIndex = tracks.findIndex(t => t.id === selectedTrackId);
                if (trackIndex > -1) {
                    tracks.splice(trackIndex, 1);
                    if (tracks.length > 0) {
                        const newIndex = Math.max(0, trackIndex - 1);
                        selectedTrackId = tracks[newIndex].id;
                    } else {
                        selectedTrackId = null;
                    }
                }
            }
            
            // --- Scenario Setup Function ---
            function setupRandomScenario() {
                ownShip = { course: 90, speed: 12, id: 'ownShip', x: 0, y: 0 };
                tracks = [];
                const numTracks = Math.floor(Math.random() * 6) + 3; // 3 to 8 tracks

                // --- Create the primary collision risk track (must give way) ---
                const riskTrack = {
                    id: 1,
                    initialBearing: 45 + (Math.random() * 20 - 10), // On starboard bow
                    initialRange: 6 + Math.random() * 2,         // 6-8 NM away
                    course: 315 + (Math.random() * 20 - 10),     // Roughly crossing course
                    speed: 10 + Math.random() * 4                // Similar speed
                };
                tracks.push(riskTrack);
                selectedTrackId = 1;

                // --- Create other background traffic to simulate a mixing bowl ---
                for (let i = 2; i <= numTracks; i++) {
                    const otherTrack = {
                        id: i,
                        initialBearing: Math.random() * 360,
                        initialRange: 3 + Math.random() * (maxRange - 3), // Don't spawn too close
                        course: Math.random() * 360,
                        speed: 5 + Math.random() * 10 // 5-15 kts
                    };
                    
                    // A simple check to prevent all tracks from being on a collision course
                    const bearingDiff = Math.abs(otherTrack.initialBearing - otherTrack.course);
                    if (bearingDiff > 160 && bearingDiff < 200) {
                        otherTrack.course = (otherTrack.course + 90) % 360; // Nudge it away
                    }
                    tracks.push(otherTrack);
                }
                
                initialize();
                isSimulationRunning = true; 
            }


            // --- Initial Setup ---
            function initialize() {
                // This function is now also used to reset scenarios
                if (tracks.length > 0) {
                    tracks.forEach(track => {
                        // Calculate absolute position based on bearing/range from ownship's current position
                        track.x = ownShip.x + track.initialRange * Math.sin(toRadians(track.initialBearing));
                        track.y = ownShip.y + track.initialRange * Math.cos(toRadians(track.initialBearing));
                    });
                }
                
                tracks.forEach(calculateAllData);
                calculateWindData();
                
                updateButtonStyles();
                updatePanelsAndRedraw();
                scaleUI();
                
                lastTimestamp = performance.now();
                if (isSimulationRunning && !gameLoop.running) {
                    gameLoop.running = true;
                    requestAnimationFrame(gameLoop);
                }
            }

             // --- Speed Control UI ---
            function updateSpeedIndicator() {
                if (simulationSpeed > 1) {
                    ffSpeedIndicator.textContent = `${simulationSpeed}x`;
                    ffSpeedIndicator.classList.remove('hidden');
                    revSpeedIndicator.classList.add('hidden');
                } else if (simulationSpeed < 1) {
                    revSpeedIndicator.textContent = `${Math.abs(simulationSpeed)}x`;
                    revSpeedIndicator.classList.remove('hidden');
                    ffSpeedIndicator.classList.add('hidden');
                } else {
                    ffSpeedIndicator.classList.add('hidden');
                    revSpeedIndicator.classList.add('hidden');
                }
            }


            // --- Event Listeners ---
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('mousemove', handleMouseMove);
	    window.addEventListener('resize', () => {
	        scaleUI();
	        sceneDirty = true;    // size change requires re‑draw
	    });
            
            btnVectorTime.addEventListener('click', () => {
                const currentIndex = vectorTimes.indexOf(vectorTimeInMinutes);
                const nextIndex = (currentIndex + 1) % vectorTimes.length;
                vectorTimeInMinutes = vectorTimes[nextIndex];
                btnVectorTime.textContent = vectorTimeInMinutes;
            });

            btnRange.addEventListener('click', () => {
                const currentIndex = rangeScales.indexOf(maxRange);
                const nextIndex = (currentIndex + 1) % rangeScales.length;
                maxRange = rangeScales[nextIndex];
                btnRange.textContent = maxRange.toFixed(1);
            });

	    // Weather toggle
	
	    btnWind.addEventListener('click', () => {
	       showWeather = !showWeather;
	       markSceneDirty();         // ← forces the canvas to redraw
	    });
            btnRmv.addEventListener('click', () => { showRelativeMotion = !showRelativeMotion; });
            btnCpa.addEventListener('click', () => { showCPAInfo = !showCPAInfo; });
            btnPlayPause.addEventListener('click', () => { 
                isSimulationRunning = !isSimulationRunning; 
                simulationSpeed = 1;
                updateSpeedIndicator();
            });
            btnFf.addEventListener('click', () => {
                const currentIndex = ffSpeeds.indexOf(simulationSpeed);
                simulationSpeed = ffSpeeds[(currentIndex + 1) % ffSpeeds.length];
                updateSpeedIndicator();
                isSimulationRunning = true;
            });
             btnRev.addEventListener('click', () => {
                const currentIndex = revSpeeds.indexOf(simulationSpeed);
                simulationSpeed = revSpeeds[(currentIndex + 1) % revSpeeds.length];
                updateSpeedIndicator();
                isSimulationRunning = true;
            });
            
            btnAddTrack.addEventListener('click', addTrack);
            btnDropTrack.addEventListener('click', dropTrack);
            btnScen.addEventListener('click', setupRandomScenario);
            initialize(); // Initial load of the application
            gameLoop.running = true;
            requestAnimationFrame(gameLoop); // Start the main loop
        });
    </script>
    <script>
        window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>
</body>
</html>
